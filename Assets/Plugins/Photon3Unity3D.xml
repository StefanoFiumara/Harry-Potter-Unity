<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Photon3Unity3D</name>
    </assembly>
    <members>
        <member name="T:ExitGames.Client.Photon.Hashtable">
            <summary>
            This is a substitute for the Hashtable class, missing in: Win8RT and Windows Phone. It uses a Dictionary&lt;object,object&gt; as base.
            </summary>
            <remarks>
            Please be aware that this class might act differently than the Hashtable equivalent.
            As far as Photon is concerned, the substitution is sufficiently precise.
            </remarks>
        </member>
        <member name="M:ExitGames.Client.Photon.Hashtable.Clone">
            <summary>
            Creates a shallow copy of the Hashtable.
            </summary>
            <remarks>
            A shallow copy of a collection copies only the elements of the collection, whether they are 
            reference types or value types, but it does not copy the objects that the references refer 
            to. The references in the new collection point to the same objects that the references in 
            the original collection point to.
            </remarks>
            <returns>Shallow copy of the Hashtable.</returns>
        </member>
        <member name="M:Photon.SocketServer.Security.DiffieHellmanCryptoProvider.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Photon.SocketServer.Security.DiffieHellmanCryptoProvider"/> class.
            </summary>
        </member>
        <member name="M:Photon.SocketServer.Security.DiffieHellmanCryptoProvider.DeriveSharedKey(System.Byte[])">
            <summary>
            Derives the shared key is generated from the secret agreement between two parties, 
            given a byte array that contains the second party's public key. 
            </summary>
            <param name="otherPartyPublicKey">
            The second party's public key.
            </param>
        </member>
        <member name="P:Photon.SocketServer.Security.DiffieHellmanCryptoProvider.PublicKey">
            <summary>
            Gets the public key that can be used by another DiffieHellmanCryptoProvider object 
            to generate a shared secret agreement.
            </summary>
        </member>
        <member name="P:Photon.SocketServer.Security.DiffieHellmanCryptoProvider.SharedKey">
            <summary>
             Gets the shared key that is used by the current instance for cryptographic operations.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.peerID">
            This ID is assigned by the Realtime Server upon connection.
            The application does not have to care about this, but it is useful in debugging.
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.peerConnectionState">
            <summary>
            This is the (low level) connection state of the peer. It's internal and based on eNet's states.
            </summary>
            <remarks>Applications can read the "high level" state as PhotonPeer.PeerState, which uses a different enum.</remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.serverTimeOffset">
            <summary>
            The serverTimeOffset is serverTimestamp - localTime. Used to approximate the serverTimestamp with help of localTime
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.PeerBase.Connect(System.String,System.String)">
            <summary>Connect to server and send Init (which inlcudes the appId).</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.PeerBase.DispatchIncomingCommands">
            <summary>
            Checks the incoming queue and Dispatches received data if possible.
            </summary>
            <returns>If a Dispatch happened or not, which shows if more Dispatches might be needed.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PeerBase.SendOutgoingCommands">
            <summary>
            Checks outgoing queues for commands to send and puts them on their way.
            This creates one package per go in UDP.
            </summary>
            <returns>If commands are not sent, cause they didn't fit into the package that's sent.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PeerBase.SerializeMessageToMessage(System.Object,System.Boolean,System.Byte[],System.Boolean)">
            <summary> Returns the UDP Payload starting with Magic Number for binary protocol </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.PeerBase.SerializeRawMessageToMessage(System.Byte[],System.Boolean,System.Byte[],System.Boolean)">
            <summary> Returns the UDP Payload starting with Magic Number for binary protocol </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.mtu">
            <summary> Maximum Transfer Unit to be used for UDP+TCP</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.rhttpMinConnections">
            <summary> (default=2) Rhttp: minimum number of open connections </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.rhttpMaxConnections">
            <summary> (default=6) Rhttp: maximum number of open connections, should be > rhttpMinConnections </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.PeerBase.ExchangeKeysForEncryption">
            <summary>
            Internally uses an operation to exchange encryption keys with the server.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PeerBase.NetworkSimRun">
            <summary>
            Core of the Network Simulation, which is available in Debug builds.
            Called by a timer in intervals.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PeerBase.TrafficStatsEnabled">
            <summary>
            Enables or disables collection of statistics.
            Setting this to true, also starts the stopwatch to measure the timespan the stats are collected.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PeerBase.NetworkSimulationSettings">
            <summary>
            Gets the currently used settings for the built-in network simulation.
            Please check the description of NetworkSimulationSet for more details.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PeerBase.BytesOut">
            <summary>
            Count of all bytes going out (including headers)
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PeerBase.BytesIn">
            <summary>
            Count of all bytes coming in (including headers)
            </summary>
        </member>
        <member name="T:ExitGames.Client.Photon.PeerBase.ConnectionStateValue">
            <summary>
            This is the replacement for the const values used in eNet like: PS_DISCONNECTED, PS_CONNECTED, etc.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.ConnectionStateValue.Disconnected">
            <summary>No connection is available. Use connect.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.ConnectionStateValue.Connecting">
            <summary>Establishing a connection already. The app should wait for a status callback.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.ConnectionStateValue.Connected">
            <summary>
            The low level connection with Photon is established. On connect, the library will automatically
            send an Init package to select the application it connects to (see also PhotonPeer.Connect()).
            When the Init is done, IPhotonPeerListener.OnStatusChanged() is called with connect.
            </summary>
            <remarks>Please note that calling operations is only possible after the OnStatusChanged() with StatusCode.Connect.</remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.ConnectionStateValue.Disconnecting">
            <summary>Connection going to be ended. Wait for status callback.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.ConnectionStateValue.AcknowledgingDisconnect">
            <summary>Acknowledging a disconnect from Photon. Wait for status callback.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerBase.ConnectionStateValue.Zombie">
            <summary>Connection not properly disconnected.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.EnetPeer.channels">
            <summary>Will contain channel 0xFF and any other.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.EnetPeer.sentReliableCommands">
            <summary>One list for all channels keeps sent commands (for re-sending).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.EnetPeer.outgoingAcknowledgementsList">
            <summary>One list for all channels keeps acknowledgements.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.DispatchIncomingCommands">
            <summary>
            Checks the incoming queue and Dispatches received data if possible.
            </summary>
            <returns>If a Dispatch happened or not, which shows if more Dispatches might be needed.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.SendAcksOnly">
            <summary>
            gathers acks until udp-packet is full and sends it!
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.SendOutgoingCommands">
            <summary>
            gathers commands from all (out)queues until udp-packet is full and sends it!
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.AreReliableCommandsInTransit">
            <summary>
            Checks if any channel has a outgoing reliable command.
            </summary>
            <returns>True if any channel has a outgoing reliable command. False otherwise.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.EnqueueOperation(System.Collections.Generic.Dictionary{System.Byte,System.Object},System.Byte,System.Boolean,System.Byte,System.Boolean,ExitGames.Client.Photon.PeerBase.EgMessageType)">
            <summary>
            Checks connected state and channel before operation is serialized and enqueued for sending.
            </summary>
            <param name="parameters">operation parameters</param>
            <param name="opCode">code of operation</param>
            <param name="sendReliable">send as reliable command</param>
            <param name="channelId">channel (sequence) for command</param>
            <param name="encrypt">encrypt or not</param>
            <param name="messageType">usually EgMessageType.Operation</param>
            <returns>if operation could be enqueued</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.CreateAndEnqueueCommand(System.Byte,System.Byte[],System.Byte)">
            <summary>reliable-udp-level function to send some byte[] to the server via un/reliable command</summary>
            <remarks>only called when a custom operation should be send</remarks>
            <param name="commandType">(enet) command type</param>
            <param name="payload">data to carry (operation)</param>
            <param name="channelNumber">channel in which to send</param>
            <returns>the invocation ID for this operation (the payload)</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.SerializeOperationToMessage(System.Byte,System.Collections.Generic.Dictionary{System.Byte,System.Object},ExitGames.Client.Photon.PeerBase.EgMessageType,System.Boolean)">
            <summary> Returns the UDP Payload starting with Magic Number for binary protocol </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.ReceiveIncomingCommands(System.Byte[],System.Int32)">
            <summary>reads incoming udp-packages to create and queue incoming commands*</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.QueueIncomingCommand(ExitGames.Client.Photon.NCommand)">
            <summary>queues incoming commands in the correct order as either unreliable, reliable or unsequenced. return value determines if the command is queued / done.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.EnetPeer.RemoveSentReliableCommand(System.Int32,System.Int32)">
            <summary>removes commands which are acknowledged*</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.StatusCode">
            <summary>
            Enumeration of situations that change the peers internal status. 
            Used in calls to OnStatusChanged to inform your application of various situations that might happen.
            </summary>
            <remarks>
            Most of these codes are referenced somewhere else in the documentation when they are relevant to methods.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.Connect">
            <summary>the PhotonPeer is connected.<br/>See {@link PhotonListener#OnStatusChanged}*</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.Disconnect">
            <summary>the PhotonPeer just disconnected.<br/>See {@link PhotonListener#OnStatusChanged}*</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.Exception">
            <summary>the PhotonPeer encountered an exception and will disconnect, too.<br/>See {@link PhotonListener#OnStatusChanged}*</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.ExceptionOnConnect">
            <summary>the PhotonPeer encountered an exception while opening the incoming connection to the server. The server could be down / not running or the client has no network or a misconfigured DNS.<br/>See {@link PhotonListener#OnStatusChanged}*</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.SecurityExceptionOnConnect">
            <summary>Used on platforms that throw a security exception on connect. Unity3d does this, e.g., if a webplayer build could not fetch a policy-file from a remote server.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.QueueOutgoingReliableWarning">
            <summary>PhotonPeer outgoing queue is filling up. send more often.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.QueueOutgoingUnreliableWarning">
            <summary>PhotonPeer outgoing queue is filling up. send more often.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.SendError">
            <summary>Sending command failed. Either not connected, or the requested channel is bigger than the number of initialized channels.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.QueueOutgoingAcksWarning">
            <summary>PhotonPeer outgoing queue is filling up. send more often.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.QueueIncomingReliableWarning">
            <summary>PhotonPeer incoming queue is filling up. Dispatch more often.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.QueueIncomingUnreliableWarning">
            <summary>PhotonPeer incoming queue is filling up. Dispatch more often.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.QueueSentWarning">
            <summary>PhotonPeer incoming queue is filling up. Dispatch more often.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.ExceptionOnReceive">
            <summary>Exception, if a server cannot be connected. Most likely, the server is not responding. Ask user to try again later.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.InternalReceiveException">
            <summary>Exception, if a server cannot be connected. Most likely, the server is not responding. Ask user to try again later.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.TimeoutDisconnect">
            <summary>Disconnection due to a timeout (client did no longer receive ACKs from server).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.DisconnectByServer">
            <summary>Disconnect by server due to timeout (received a disconnect command, cause server misses ACKs of client).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.DisconnectByServerUserLimit">
            <summary>Disconnect by server due to concurrent user limit reached (received a disconnect command).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.DisconnectByServerLogic">
            <summary>Disconnect by server due to server's logic (received a disconnect command).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.TcpRouterResponseOk">
            <summary>Tcp Router Response. Only used when Photon is setup as TCP router! Routing is ok.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.TcpRouterResponseNodeIdUnknown">
            <summary>Tcp Router Response. Only used when Photon is setup as TCP router! Routing node unknown. Check client connect values.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.TcpRouterResponseEndpointUnknown">
            <summary>Tcp Router Response. Only used when Photon is setup as TCP router! Routing endpoint unknown.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.TcpRouterResponseNodeNotReady">
            <summary>Tcp Router Response. Only used when Photon is setup as TCP router! Routing not setup yet. Connect again.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.EncryptionEstablished">
            <summary>(1048) Value for OnStatusChanged()-call, when the encryption-setup for secure communication finished successfully.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.StatusCode.EncryptionFailedToEstablish">
            <summary>(1049) Value for OnStatusChanged()-call, when the encryption-setup failed for some reason. Check debug logs.</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.IPhotonPeerListener">
            <summary>
            Callback interface for the Photon client side. Must be provided to a new PhotonPeer in its constructor.
            </summary>
            <remarks>
            These methods are used by your PhotonPeer instance to keep your app updated. Read each method's
            description and check out the samples to see how to use them.
            </remarks>
        </member>
        <member name="M:ExitGames.Client.Photon.IPhotonPeerListener.DebugReturn(ExitGames.Client.Photon.DebugLevel,System.String)">
            <summary>
            Provides textual descriptions for various error conditions and noteworthy situations.
            In cases where the application needs to react, a call to OnStatusChanged is used.
            OnStatusChanged gives "feedback" to the game, DebugReturn provies human readable messages 
            on the background.
            </summary>
            <remarks>
            All debug output of the library will be reported through this method. Print it or put it in a 
            buffer to use it on-screen. Use PhotonPeer.DebugOut to select how verbose the output is.
            </remarks>
            <param name="level">DebugLevel (severity) of the message.</param>
            <param name="message">Debug text. Print to System.Console or screen.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.IPhotonPeerListener.OnOperationResponse(ExitGames.Client.Photon.OperationResponse)">
            <summary>
            Callback method which gives you (async) responses for called operations.
            </summary>
            <remarks>
            Like methods, operations can have a result. As operation-calls are non-blocking, the response
            for any operation of this peer is provided by this method. 
            As example: Joining a room on a Lite-based server will return a list of players currently in gamey
            your actorNumber and some other values.
            
            This method is used as general callback for all operations. Each response corresponds to a certain 
            "type" of operation by its OperationCode (see: <see cref="!:Operations"/>).<para></para>
            
            The "Lite Application" uses these OpCodes:
             * <see cref="F:ExitGames.Client.Photon.Lite.LiteOpCode.Join"/> for OpJoin, contains the actorNr of "this" player
             * <see cref="F:ExitGames.Client.Photon.Lite.LiteOpCode.Leave"/> when leaving a room
             * <see cref="F:ExitGames.Client.Photon.Lite.LiteOpCode.RaiseEvent"/> for OpRaiseEvent, if this was sent as reliable command
             * <see cref="F:ExitGames.Client.Photon.Lite.LiteOpCode.SetProperties"/> for OpSetPropertiesOfActor and OpSetPropertiesOfGame
            </remarks>
            <example>
            When you join a room, the server will assign a consecutive number to each client: the 
            "actorNr" or "player number". This is sent back in the OperationResult's 
            Parameters as value of key <see cref="F:ExitGames.Client.Photon.Lite.LiteEventKey.ActorNr"/>.<para></para>
            
            Fetch your actorNr of a Join response like this:<para></para>
            <c>int actorNr = (int)operationResponse[(byte)LiteOpKey.ActorNr];</c>
            </example>
            <param name="operationResponse">The response to an operation\-call.</param>                                                          
        </member>
        <member name="M:ExitGames.Client.Photon.IPhotonPeerListener.OnStatusChanged(ExitGames.Client.Photon.StatusCode)">
            <summary>
            OnStatusChanged is called to let the game know when asyncronous actions finished or when errors happen.
            </summary>
            <remarks>
            Not all of the many StatusCode values will apply to your game. Example: If you don't use encryption, 
            the respective status changes are never made.
            
            The values are all part of the StatusCode enumeration and described value-by-value.
            </remarks>
            <param name="statusCode">A code to identify the situation.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.IPhotonPeerListener.OnEvent(ExitGames.Client.Photon.EventData)">
            <summary>
            Called whenever an event from the Photon Server is dispatched.
            </summary>
            <remarks>
            Events are used for communication between clients and allow the server to update clients over time. 
            The creation of an event is often triggered by an operation (called by this client or an other). 
            
            Each event carries its specific content in its Parameters. Your application knows which content to
            expect by checking the event's 'type', given by the event's Code.
            
            Events can be defined and extended server-side. 
            
            If you use the Lite application as base, several events like EvJoin and EvLeave are already defined.
            For these events and their Parameters, the library provides constants, so check:
            LiteEventCode and LiteEventKey classes.
            Lite also allows you to come up with custom events on the fly, purely client-side. To do so, use 
            LitePeer.OpRaiseEvent.<para></para>
            
            Events are buffered on the client side and must be Dispatched. This way, OnEvent is always taking
            place in the same thread as a <see cref="M:ExitGames.Client.Photon.PhotonPeer.DispatchIncomingCommands"/> call.
            </remarks>
            <param name="eventData">The event currently being dispatched.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.IPhotonSocket.TryParseAddress(System.String,System.String@,System.UInt16@)">
            <summary>
            Ports of IPv4 Addresses are of type ushort. They are used as int usually though.
            </summary>
        </member>
        <member name="T:ExitGames.Client.Photon.Lite.LiteEventCode">
            <summary>
            Lite - Event codes.
            These codes are defined by the Lite application's logic on the server side.
            Other application's won't necessarily use these.
            </summary>
            <remarks>If your game is built as extension of Lite, don't re-use these codes for your custom events.</remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventCode.Join">
            <summary>(255) Event Join: someone joined the game</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventCode.Leave">
            <summary>(254) Event Leave: someone left the game</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventCode.PropertiesChanged">
            <summary>(253) Event PropertiesChanged</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventCode.Disconnect">
            <summary>(252) Event Disconnect</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.Lite.LiteEventKey">
            <summary>
            Lite - Keys of event-parameters that are defined by the Lite application logic.
            To keep things lean (in terms of bandwidth), we use byte keys to identify values in events within Photon.
            In Lite, you can send custom events by defining a EventCode and some content. This custom content is a Hashtable,
            which can use any type for keys and values. The parameter for operation RaiseEvent and the resulting
            Events use key (byte)245 for the custom content. The constant for this is: Data or
            <see cref="F:ExitGames.Client.Photon.Lite.LiteEventKey.CustomContent" text="LiteEventKey.CustomContent Field"/>.
            </summary>
            <remarks>
            If your game is built as extension of Lite, don't re-use these codes for your custom events.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventKey.ActorNr">
            <summary>(254) Playernumber of the player who triggered the event.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventKey.TargetActorNr">
            <summary>(253) Playernumber of the player who is target of an event (e.g. changed properties).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventKey.ActorList">
            <summary>(252) List of playernumbers currently in the room.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventKey.Properties">
            <summary>(251) Set of properties (a Hashtable).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventKey.ActorProperties">
            <summary>(249) Key for actor (player) property set (Hashtable).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventKey.GameProperties">
            <summary>(248) Key for game (room) property set (Hashtable).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventKey.Data">
            <summary>(245) Custom Content of an event (a Hashtable in Lite).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteEventKey.CustomContent">
            <summary>
            (245) The Lite operation RaiseEvent will place the Hashtable with your custom event-content under this key.</summary>
            <remarks>Alternative for: Data!</remarks>
        </member>
        <member name="T:ExitGames.Client.Photon.Lite.LiteOpCode">
            <summary>
            Lite - Operation Codes.
            This enumeration contains the codes that are given to the Lite Application's
            operations. Instead of sending "Join", this enables us to send the byte 255.
            </summary>
            <remarks>
            Other applications (the MMO demo or your own) could define other operations and other codes.
            If your game is built as extension of Lite, don't re-use these codes for your custom events.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpCode.Join">
            <summary>(255) Code for OpJoin, to get into a room.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpCode.Leave">
            <summary>(254) Code for OpLeave, to get out of a room.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpCode.RaiseEvent">
            <summary>(253) Code for OpRaiseEvent (not same as eventCode).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpCode.SetProperties">
            <summary>(252) Code for OpSetProperties.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpCode.GetProperties">
            <summary>(251) Operation code for OpGetProperties.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpCode.ChangeGroups">
            <summary>(248) Operation code to change interest groups in Rooms (Lite application and extending ones).</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.Lite.LiteOpKey">
             <summary>
             Lite - keys for parameters of operation requests and responses (short: OpKey).
             </summary>
             <remarks>
             These keys match a definition in the Lite application (part of the server SDK).
             If your game is built as extension of Lite, don't re-use these codes for your custom events.
            
             These keys are defined per application, so Lite has different keys than MMO or your
             custom application. This is why these are not an enumeration.
             Lite and Lite Lobby will use the keys 255 and lower, to give you room for your own codes.
            
             Keys for operation-parameters could be assigned on a per operation basis, but
             it makes sense to have fixed keys for values which are used throughout the whole
             application.
             </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.Asid">
            <summary>(255) Code of the room name. Used in OpJoin (Asid = Application Session ID).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.RoomName">
            <summary>(255) Code of the room name. Used in OpJoin.</summary>
            <remarks>Alternative for: Asid!</remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.GameId">
            <summary>(255) Code of the game id (a unique room name). Used in OpJoin.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.ActorNr">
            <summary>(254) Code of the Actor of an operation. Used for property get and set.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.TargetActorNr">
            <summary>(253) Code of the target Actor of an operation. Used for property set. Is 0 for game</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.ActorList">
            <summary>(252) Code for list of players in a room. Currently not used.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.Properties">
            <summary>
            (251) Code for property set (Hashtable). This key is used when sending only one set of properties.
            If either ActorProperties or GameProperties are used (or both), check those keys.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.Broadcast">
            <summary>(250) Code for broadcast parameter of OpSetProperties method.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.ActorProperties">
            <summary>(249) Code for property set (Hashtable).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.GameProperties">
            <summary>(248) Code for property set (Hashtable).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.Cache">
            <summary>(247) Code for caching events while raising them.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.ReceiverGroup">
            <summary>(246) Code to select the receivers of events (used in Lite, Operation RaiseEvent).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.Data">
            <summary>(245) Code of data of an event. Used in OpRaiseEvent.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.Code">
            <summary>(244) Code used when sending some code-related parameter, like OpRaiseEvent's event-code.</summary>
            <remarks>This is not the same as the Operation's code, which is no longer sent as part of the parameter Dictionary in Photon 3.</remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.Group">
            <summary>(240) Code for "group" operation-parameter (as used in Op RaiseEvent).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.Remove">
            <summary>
            (239) The "Remove" operation-parameter can be used to remove something from a list. E.g. remove groups from player's interest groups.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LiteOpKey.Add">
            <summary>
            (238) The "Add" operation-parameter can be used to add something to some list or set. E.g. add groups to player's interest groups.
            </summary>
        </member>
        <member name="T:ExitGames.Client.Photon.Lite.LitePropertyTypes">
            <summary>
            Lite - Flags for "types of properties", being used as filter in OpGetProperties.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LitePropertyTypes.None">
            <summary>(0x00) Flag type for no property type.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LitePropertyTypes.Game">
            <summary>(0x01) Flag type for game-attached properties.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LitePropertyTypes.Actor">
            <summary>(0x02) Flag type for actor related propeties.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.LitePropertyTypes.GameAndActor">
            <summary>(0x01) Flag type for game AND actor properties. Equal to 'Game'</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.Lite.EventCaching">
            <summary>
            Lite - OpRaiseEvent allows you to cache events and automatically send them to joining players in a room.
            Events are cached per event code and player: Event 100 (example!) can be stored once per player.
            Cached events can be modified, replaced and removed.
            </summary>
            <remarks>
            Caching works only combination with ReceiverGroup options Others and All.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.DoNotCache">
            <summary>Default value (not sent).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.MergeCache">
            <summary>Will merge this event's keys with those already cached.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.ReplaceCache">
            <summary>Replaces the event cache for this eventCode with this event's content.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.RemoveCache">
            <summary>Removes this event (by eventCode) from the cache.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.AddToRoomCache">
            <summary>Adds an event to the room's cache</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.AddToRoomCacheGlobal">
            <summary>Adds this event to the cache for actor 0 (becoming a "globally owned" event in the cache).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.RemoveFromRoomCache">
            <summary>Remove fitting event from the room's cache.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.RemoveFromRoomCacheForActorsLeft">
            <summary>Removes events of players who already left the room (cleaning up).</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.SliceIncreaseIndex">
            <summary>Increase the index of the sliced cache.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.SliceSetIndex">
            <summary>Set the index of the sliced cache. You must set RaiseEventOptions.CacheSliceIndex for this.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.SlicePurgeIndex">
            <summary>Purge cache slice with index. Exactly one slice is removed from cache. You must set RaiseEventOptions.CacheSliceIndex for this.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.EventCaching.SlicePurgeUpToIndex">
            <summary>Purge cache slices with specified index and anything lower than that. You must set RaiseEventOptions.CacheSliceIndex for this.</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.Lite.ReceiverGroup">
            <summary>
            Lite - OpRaiseEvent lets you chose which actors in the room should receive events.
            By default, events are sent to "Others" but you can overrule this.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.ReceiverGroup.Others">
            <summary>Default value (not sent). Anyone else gets my event.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.ReceiverGroup.All">
            <summary>Everyone in the current room (including this peer) will get this event.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.Lite.ReceiverGroup.MasterClient">
            <summary>The server sends this event only to the actor with the lowest actorNumber.</summary>
            <remarks>The "master client" does not have special rights but is the one who is in this room the longest time.</remarks>
        </member>
        <member name="T:ExitGames.Client.Photon.Lite.LitePeer">
             <summary>
             A LitePeer is an extended PhotonPeer and implements the operations offered by the "Lite" Application
             of the Photon Server SDK.
             </summary>
             <remarks>
             This class is used by our samples and allows rapid development of simple games. You can use rooms and
             properties and send events. For many games, this is a good start.
            
             Operations are prefixed as "Op" and are always asynchronous. In most cases, an OperationResult is
             provided by a later call to OnOperationResult.
             </remarks>
        </member>
        <member name="T:ExitGames.Client.Photon.PhotonPeer">
            <summary>
            Instances of the PhotonPeer class are used to connect to a Photon server and communicate with it.
            </summary>
            <remarks>
            A PhotonPeer instance allows communication with the Photon Server, which in turn distributes messages
            to other PhotonPeer clients.<para></para>
            An application can use more than one PhotonPeer instance, which are treated as separate users on the
            server. Each should have its own listener instance, to separate the operations, callbacks and events.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.PhotonPeer.NoSocket">
            <summary>False if this library build contains C# Socket code. If true, you must set some type as SocketImplementation before connecting.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.TrafficStatsReset">
            <summary>
            Creates new instances of TrafficStats and starts a new timer for those.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PhotonPeer.peerBase">
            <summary>Implements the message-protocol, based on the underlying network protocol (udp, tcp, http).</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.#ctor(ExitGames.Client.Photon.IPhotonPeerListener,ExitGames.Client.Photon.ConnectionProtocol)">
            <summary>
            Creates a new PhotonPeer instance to communicate with Photon and selects either UDP or TCP as
            protocol. We recommend UDP.
            </summary>
            <param name="listener">a IPhotonPeerListener implementation</param>
            <param name="protocolType">Protocol to use to connect to Photon.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.#ctor(ExitGames.Client.Photon.IPhotonPeerListener)">
            <summary>
            Creates a new PhotonPeer instance to communicate with Photon.<para></para>
            Connection is UDP based, except for Silverlight.
            </summary>
            <param name="listener">a IPhotonPeerListener implementation</param>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.#ctor(ExitGames.Client.Photon.IPhotonPeerListener,System.Boolean)">
            <summary>
            Deprecated. Please use: PhotonPeer(IPhotonPeerListener listener, ConnectionProtocol protocolType).
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.Connect(System.String,System.String)">
             <summary>
             This method does a DNS lookup (if necessary) and connects to the given serverAddress.
            
             The return value gives you feedback if the address has the correct format. If so, this
             starts the process to establish the connection itself, which might take a few seconds.
            
             When the connection is established, a callback to IPhotonPeerListener.OnStatusChanged
             will be done. If the connection can't be established, despite having a valid address,
             the OnStatusChanged is called with an error-value.
            
             The applicationName defines the application logic to use server-side and it should match the name of
             one of the apps in your server's config.
            
             By default, the applicationName is "Lite" but other samples use "LiteLobby" and "MmoDemo" in
             Connect(). You can setup your own application and name it any way you like.
             </summary>
             <param name="serverAddress">
             Address of the Photon server. Format: ip:port (e.g. 127.0.0.1:5055) or hostname:port (e.g. localhost:5055)
             </param>
             <param name="applicationName">
             The name of the application to use within Photon or the appId of PhotonCloud.
             Should match a "Name" for an application, as setup in your PhotonServer.config.
             </param>
             <returns>
             true if IP is available (DNS name is resolved) and server is being connected. false on error.
             </returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.Disconnect">
             <summary>
             This method initiates a mutual disconnect between this client and the server.
             </summary>
             <remarks>
             Calling this method does not immediately close a connection. Disconnect lets the server
             know that this client is no longer listening. For the server, this is a much faster way
             to detect that the client is gone but it requires the client to send a few final messages.
            
             On completion, OnStatusChanged is called with the StatusCode.Disconnect.
            
             If the client is disconnected already or the connection thread is stopped, then there is no callback.
            
             Lite: The default server logic will leave any joined game and trigger the respective event
             (<see cref="F:ExitGames.Client.Photon.Lite.LiteEventCode.Leave" text="LiteEventCode.Leave"/>) for the remaining players.
             </remarks>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.StopThread">
            <summary>
            This method immediately closes a connection (pure client side) and ends related listening Threads.
            </summary>
            <remarks>
            Unlike Disconnect, this method will simply stop to listen to the server. Udp connections will timeout.
            If the connections was open, this will trigger a callback to OnStatusChanged with code StatusCode.Disconnect.
            </remarks>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.FetchServerTimestamp">
             <summary>
             This will fetch the server's timestamp and update the approximation for property ServerTimeInMilliseconds.
            
             The server time approximation will NOT become more accurate by repeated calls. Accuracy currently depends
             on a single roundtrip which is done as fast as possible.
            
             The command used for this is immediately acknowledged by the server. This makes sure the roundtrip time is
             low and the timestamp + rountriptime / 2 is close to the original value.
             </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.EstablishEncryption">
             <summary>
             This method creates a public key for this client and exchanges it with the server.
             </summary>
             <remarks>
             Encryption is not instantly available but calls OnStatusChanged when it finishes.
             Check for StatusCode EncryptionEstablished and EncryptionFailedToEstablish.
            
             Calling this method sets IsEncryptionAvailable to false.
             This method must be called before the "encrypt" parameter of OpCustom can be used.
             </remarks>
             <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.Service">
             <summary>
             This method excutes DispatchIncomingCommands and SendOutgoingCommands in your application Thread-context.
             </summary>
             <remarks>
             The Photon client libraries are designed to fit easily into a game or application. The application
             is in control of the context (thread) in which incoming events and responses are executed and has
             full control of the creation of UDP/TCP packages.
            
             Sending packages and dispatching received messages are two separate tasks. Service combines them
             into one method at the cost of control. It calls DispatchIncomingCommands and SendOutgoingCommands.
            
             Call this method regularly (2..20 times a second).
            
             This will Dispatch ANY remaining buffered responses and events AND will send queued outgoing commands.
             Fewer calls might be more effective if a device cannot send many packets per second, as multiple
             operations might be combined into one package.
             </remarks>
             <example>
             You could replace Service by:
            
                 while (DispatchIncomingCommands()); //Dispatch until everything is Dispatched...
                 SendOutgoingCommands(); //Send a UDP/TCP package with outgoing messages
             </example>
             <seealso cref="M:ExitGames.Client.Photon.PhotonPeer.DispatchIncomingCommands"/>
             <seealso cref="M:ExitGames.Client.Photon.PhotonPeer.SendOutgoingCommands"/>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.SendOutgoingCommands">
             <summary>
             This method creates a UDP/TCP package for outgoing commands (operations and acknowledgements)
             and sends them to the server.
             This method is also called by Service().
             </summary>
             <remarks>
             As the Photon library does not create any UDP/TCP packages by itself. Instead, the application
             fully controls how many packages are sent and when. A tradeoff, an application will
             lose connection, if it is no longer calling SendOutgoingCommands or Service.
            
             If multiple operations and ACKs are waiting to be sent, they will be aggregated into one
             package. The package fills in this order:
               ACKs for received commands
               A "Ping" - only if no reliable data was sent for a while
               Starting with the lowest Channel-Nr:
                 Reliable Commands in channel
                 Unreliable Commands in channel
            
             This gives a higher priority to lower channels.
            
             A longer interval between sends will lower the overhead per sent operation but
             increase the internal delay (which adds "lag").
            
             Call this 2..20 times per second (depending on your target platform).
             </remarks>
             <returns>The if commands are not yet sent. Udp limits it's package size, Tcp doesnt.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.DispatchIncomingCommands">
             <summary>
             This method directly causes the callbacks for events, responses and state changes
             within a IPhotonPeerListener. DispatchIncomingCommands only executes a single received
             command per call. If a command was dispatched, the return value is true and the method
             should be called again.
             This method is called by Service() until currently available commands are dispatched.
             </summary>
             <remarks>
             In general, this method should be called until it returns false. In a few cases, it might
             make sense to pause dispatching (if a certain state is reached and the app needs to load
             data, before it should handle new events).
            
             The callbacks to the peer's IPhotonPeerListener are executed in the same thread that is
             calling DispatchIncomingCommands. This makes things easier in a game loop: Event execution
             won't clash with painting objects or the game logic.
             </remarks>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.VitalStatsToString(System.Boolean)">
            <summary>
            Returns a string of the most interesting connection statistics.
            When you have issues on the client side, these might contain hints about the issue's cause.
            </summary>
            <param name="all">If true, Incoming and Outgoing low-level stats are included in the string.</param>
            <returns>Stats as string.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.OpCustom(System.Byte,System.Collections.Generic.Dictionary{System.Byte,System.Object},System.Boolean)">
            <summary>
            Channel-less wrapper for OpCustom().
            </summary>
            <param name="customOpCode">Operations are handled by their byte\-typed code. The codes of the
                                       "Lite" application are in the struct <see cref="T:ExitGames.Client.Photon.Lite.LiteOpCode"/>.</param>
            <param name="customOpParameters">Containing parameters as key\-value pair. The key is byte\-typed, while the value is any serializable datatype.</param>
            <param name="sendReliable">Selects if the operation must be acknowledged or not. If false, the
                                       operation is not guaranteed to reach the server.</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.OpCustom(System.Byte,System.Collections.Generic.Dictionary{System.Byte,System.Object},System.Boolean,System.Byte)">
            <summary>
            Allows the client to send any operation to the Photon Server by setting any opCode and the operation's parameters.
            </summary>
            <remarks></remarks>
            Photon can be extended with new operations which are identified by a single
            byte, defined server side and known as operation code (opCode). Similarly, the operation's parameters
            are defined server side as byte keys of values, which a client sends as customOpParameters
            accordingly.<para></para>
            This is explained in more detail as "<see cref="!:Operations" text="Custom Operations"/>".
            <param name="customOpCode">Operations are handled by their byte\-typed code. The codes of the
                                       "Lite" application are in the struct <see cref="T:ExitGames.Client.Photon.Lite.LiteOpCode"/>.</param>
            <param name="customOpParameters">Containing parameters as key\-value pair. The key is byte\-typed, while the value is any serializable datatype.</param>
            <param name="sendReliable">Selects if the operation must be acknowledged or not. If false, the
                                       operation is not guaranteed to reach the server.</param>
            <param name="channelId">The channel in which this operation should be sent.</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.OpCustom(System.Byte,System.Collections.Generic.Dictionary{System.Byte,System.Object},System.Boolean,System.Byte,System.Boolean)">
             <summary>
             Allows the client to send any operation to the Photon Server by setting any opCode and the operation's parameters.
             </summary>
             <summary>
             Variant with encryption parameter.
            
             Use this only after encryption was established by EstablishEncryption and waiting for the OnStateChanged callback.
             </summary>
             <param name="customOpCode">Operations are handled by their byte\-typed code. The codes of the
                                        "Lite" application are in the struct <see cref="T:ExitGames.Client.Photon.Lite.LiteOpCode"/>.</param>
             <param name="customOpParameters">Containing parameters as key\-value pair. The key is byte\-typed, while the value is any serializable datatype.</param>
             <param name="sendReliable">Selects if the operation must be acknowledged or not. If false, the
                                        operation is not guaranteed to reach the server.</param>
             <param name="channelId">The channel in which this operation should be sent.</param>
             <param name="encrypt">Can only be true, while IsEncryptionAvailable is true, too.</param>
             <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.OpCustom(ExitGames.Client.Photon.OperationRequest,System.Boolean,System.Byte,System.Boolean)">
             <summary>
             Allows the client to send any operation to the Photon Server by setting any opCode and the operation's parameters.
             </summary>
             <remarks>
             Variant with an OperationRequest object.
            
             This variant offers an alternative way to describe a operation request. Operation code and it's parameters
             are wrapped up in a object. Still, the parameters are a Dictionary.
             </remarks>
             <param name="operationRequest">The operation to call on Photon.</param>
             <param name="sendReliable">Use unreliable (false) if the call might get lost (when it's content is soon outdated).</param>
             <param name="channelId">Defines the sequence of requests this operation belongs to.</param>
             <param name="encrypt">Encrypt request before sending. Depends on IsEncryptionAvailable.</param>
             <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.PhotonPeer.RegisterType(System.Type,System.Byte,ExitGames.Client.Photon.SerializeMethod,ExitGames.Client.Photon.DeserializeMethod)">
             <summary>
             Registers new types/classes for de/serialization and the fitting methods to call for this type.
             </summary>
             <remarks>
             SerializeMethod and DeserializeMethod are complementary: Feed the product of serializeMethod to
             the constructor, to get a comparable instance of the object.
            
             After registering a Type, it can be used in events and operations and will be serialized like
             built-in types.
             </remarks>
             <param name="customType">Type (class) to register.</param>
             <param name="code">A byte-code used as shortcut during transfer of this Type.</param>
             <param name="serializeMethod">Method delegate to create a byte[] from a customType instance.</param>
             <param name="constructor">Method delegate to create instances of customType's from byte[].</param>
             <returns>If the Type was registered successfully.</returns>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.SocketImplementation">
            <summary>
            Can be used to set a UDP IPhotonSocket implementation at runtime (before connecting) 
            in compatible DLL builds.
            </summary>
            <remarks>
            This won't work for TCP and regular C# libraries. Get in contact with us.
            </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.DebugOut">
            <summary>
            Sets the level (and amount) of debug output provided by the library.
            </summary>
            <remarks>
            This affects the callbacks to IPhotonPeerListener.DebugReturn.
            Default Level: Error.
            </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.Listener">
            <summary>
            Gets the IPhotonPeerListener of this instance (set in constructor).
            Can be used in derived classes for Listener.DebugReturn().
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.BytesIn">
            <summary>
            Gets count of all bytes coming in (including headers, excluding UDP/TCP overhead)
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.BytesOut">
            <summary>
            Gets count of all bytes going out (including headers, excluding UDP/TCP overhead)
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.ByteCountCurrentDispatch">
             <summary>
             Gets the size of the dispatched event or operation-result in bytes.
             This value is set before OnEvent() or OnOperationResponse() is called (within DispatchIncomingCommands()).
             </summary>
             <remarks>
             Get this value directly in OnEvent() or OnOperationResponse(). Example:
             void OnEvent(...) {
               int eventSizeInBytes = this.peer.ByteCountCurrentDispatch;
               //...
            
             void OnOperationResponse(...) {
               int resultSizeInBytes = this.peer.ByteCountCurrentDispatch;
               //...
             </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.CommandInfoCurrentDispatch">
            <summary>Returns the debug string of the event or operation-response currently being dispatched or string. Empty if none.</summary>
            <remarks>In a release build of the lib, this will always be empty.</remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.ByteCountLastOperation">
            <summary>
            Gets the size of the last serialized operation call in bytes.
            The value includes all headers for this single operation but excludes those of UDP, Enet Package Headers and TCP.
            </summary>
            <remarks>
            Get this value immediately after calling an operation. Example:
            this.litepeer.OpJoin("myroom");
            int opjoinByteCount = this.peer.ByteCountLastOperation;
            </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.TrafficStatsEnabled">
            <summary>
            Enables the traffic statistics of a peer: TrafficStatsIncoming, TrafficStatsOutgoing and TrafficstatsGameLevel (nothing else).
            Default value: false (disabled).
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.TrafficStatsElapsedMs">
            <summary>
            Returns the count of milliseconds the stats are enabled for tracking.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.TrafficStatsIncoming">
            <summary>
            Gets the byte-count of incoming "low level" messages, which are either Enet Commands or Tcp Messages.
            These include all headers, except those of the underlying internet protocol Udp or Tcp.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.TrafficStatsOutgoing">
            <summary>
            Gets the byte-count of outgoing "low level" messages, which are either Enet Commands or Tcp Messages.
            These include all headers, except those of the underlying internet protocol Udp or Tcp.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.TrafficStatsGameLevel">
            <summary>
            Gets a statistic of incoming and outgoing traffic, split by operation, operation-result and event.
            Operations are outgoing traffic, results and events are incoming.
            Includes the per-command header sizes (Udp: Enet Command Header or Tcp: Message Header).
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.PeerState">
            <summary>
            This is the (low level) state of the connection to the server of a PhotonPeer.
            It is managed internally and read-only.
            </summary>
            <remarks>
            Don't mix this up with the StatusCode provided in IPhotonListener.OnStatusChanged().
            Applications should use the StatusCode of OnStatusChanged() to track their state, as
            it also covers the higher level initialization between a client and Photon.
            </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.PeerID">
            <summary>
            This peer's ID as assigned by the server or 0 if not using UDP. Will be 0xFFFF before the client connects.
            </summary>
            <remarks>Used for debugging only. This value is not useful in everyday Photon usage.</remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.CommandBufferSize">
             <summary>
             Initial size internal lists for incoming/outgoing commands (reliable and unreliable).
             </summary>
             <remarks>
             This sets only the initial size. All lists simply grow in size as needed. This means that
             incoming or outgoing commands can pile up and consume heap size if Service is not called
             often enough to handle the messages in either direction.
            
             Configure the WarningSize, to get callbacks when the lists reach a certain size.
            
             UDP: Incoming and outgoing commands each have separate buffers for reliable and unreliable sending.
             There are additional buffers for &quot;sent commands&quot; and &quot;ACKs&quot;.
             TCP: Only two buffers exist: incoming and outgoing commands.
             </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.RhttpMinConnections">
            <summary> (default=2) minimum number of open connections </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.RhttpMaxConnections">
            <summary> (default=6) maximum number of open connections, should be > RhttpMinConnections </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.LimitOfUnreliableCommands">
            <summary>
            Limits the queue of received unreliable commands within DispatchIncomingCommands before dispatching them.
            This works only in UDP.
            This limit is applied when you call DispatchIncomingCommands. If this client (already) received more than
            LimitOfUnreliableCommands, it will throw away the older ones instead of dispatching them. This can produce
            bigger gaps for unreliable commands but your client catches up faster.
            </summary>
            <remarks>
            This can be useful when the client couldn't dispatch anything for some time (cause it was in a room but
            loading a level).
            If set to 20, the incoming unreliable queues are truncated to 20.
            If 0, all received unreliable commands will be dispatched.
            This is a "per channel" value, so each channel can hold up to LimitOfUnreliableCommands commands.
            This value interacts with DispatchIncomingCommands: If that is called less often, more commands get skipped.
            </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.QueuedIncomingCommands">
            <summary>
            Count of all currently received but not-yet-Dispatched reliable commands
            (events and operation results) from all channels.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.QueuedOutgoingCommands">
            <summary>
            Count of all commands currently queued as outgoing, including all channels and reliable, unreliable.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.ChannelCount">
            <summary>
            Gets / sets the number of channels available in UDP connections with Photon.
            Photon Channels are only supported for UDP.
            The default ChannelCount is 2. Channel IDs start with 0 and 255 is a internal channel.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.CrcEnabled">
             <summary>
             While not connected, this controls if the next connection(s) should use a per-package CRC checksum.
             </summary>
             <remarks>
             While turned on, the client and server will add a CRC checksum to every sent package.
             The checksum enables both sides to detect and ignore packages that were corrupted during transfer.
             Corrupted packages have the same impact as lost packages: They require a re-send, adding a delay
             and could lead to timeouts.
            
             Building the checksum has a low processing overhead but increases integrity of sent and received data.
             Packages discarded due to failed CRC cecks are counted in PhotonPeer.PacketLossByCrc.
             </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.PacketLossByCrc">
            <summary>
            Count of packages dropped due to failed CRC checks for this connection.
            </summary>
            <see cref="P:ExitGames.Client.Photon.PhotonPeer.CrcEnabled"/>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.ResentReliableCommands">
            <summary>
            Count of commands that got repeated (due to local repeat-timing before an ACK was received).
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.WarningSize">
            <summary>
            The WarningSize is used test all message queues for congestion (in and out, reliable and unreliable).
            OnStatusChanged will be called with a warning if a queue holds WarningSize commands or a multiple
            of it.
            Default: 100.
            Example: If command is received, OnStatusChanged will be called when the respective command queue
            has 100, 200, 300 ... items.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.SentCountAllowance">
             <summary>
             Number of send retries before a peer is considered lost/disconnected. Default: 5.
             The initial timeout countdown of a command is calculated by the current roundTripTime + 4 * roundTripTimeVariance.
             Please note that the timeout span until a command will be resent is not constant, but based on
             the roundtrip time at the initial sending, which will be doubled with every failed retry.
            
             DisconnectTimeout and SentCountAllowance are competing settings: either might trigger a disconnect on the
             client first, depending on the values and Rountrip Time.
             </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.TimePingInterval">
            <summary>
            Sets the milliseconds without reliable command before a ping command (reliable) will be sent (Default: 1000ms).
            The ping command is used to keep track of the connection in case the client does not send reliable commands
            by itself.
            A ping (or reliable commands) will update the RoundTripTime calculation.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.DisconnectTimeout">
             <summary>
             Milliseconds after which a reliable UDP command triggers a timeout disconnect, unless acknowledged by server.
             This value currently only affects UDP connections.
             DisconnectTimeout is not an exact value for a timeout. The exact timing of the timeout depends on the frequency
             of Service() calls and commands that are sent with long roundtrip-times and variance are checked less often for
             re-sending!
            
             DisconnectTimeout and SentCountAllowance are competing settings: either might trigger a disconnect on the
             client first, depending on the values and Rountrip Time.
             Default: 10000 ms.
             </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.ServerTimeInMilliSeconds">
             <summary>
             Approximated Environment.TickCount value of server (while connected).
             </summary>
             <remarks>
             UDP: The server's timestamp is automatically fetched after connecting (once). This is done
             internally by a command which is acknowledged immediately by the server.
             TCP: The server's timestamp fetched with each ping but set only after connecting (once).
            
             The approximation will be off by +/- 10ms in most cases. Per peer/client and connection, the
             offset will be constant (unless FetchServerTimestamp() is used). A constant offset should be
             better to adjust for. Unfortunately there is no way to find out how much the local value
             differs from the original.
            
             The approximation adds RoundtripTime / 2 and uses this.LocalTimeInMilliSeconds to calculate
             in-between values (this property returns a new value per tick).
            
             The value sent by Photon equals Environment.TickCount in the logic layer (e.g. Lite).
             </remarks>
             <value>
             0 until connected.
             While connected, the value is an approximation of the server's current timestamp.
             </value>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.LocalTimeInMilliSeconds">
            <summary>
            Gets a local timestamp in milliseconds by calling SupportClass.GetTickCount().
            See LocalMsTimestampDelegate.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.LocalMsTimestampDelegate">
            <summary>
            This setter for the (local-) timestamp delegate replaces the default Environment.TickCount with any equal function.
            </summary>
            <remarks>
            About Environment.TickCount:
            The value of this property is derived from the system timer and is stored as a 32-bit signed integer.
            Consequently, if the system runs continuously, TickCount will increment from zero to Int32..::.MaxValue
            for approximately 24.9 days, then jump to Int32..::.MinValue, which is a negative number, then increment
            back to zero during the next 24.9 days.
            </remarks>
            <exception cref="T:System.Exception">Exception is thrown peer.PeerState is not PS_DISCONNECTED.</exception>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.RoundTripTime">
             <summary>
             Time until a reliable command is acknowledged by the server.
            
             The value measures network latency and for UDP it includes the server's ACK-delay (setting in config).
             In TCP, there is no ACK-delay, so the value is slightly lower (if you use default settings for Photon).
            
             RoundTripTime is updated constantly. Every reliable command will contribute a fraction to this value.
            
             This is also the approximate time until a raised event reaches another client or until an operation
             result is available.
             </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.RoundTripTimeVariance">
            <summary>
            Changes of the roundtriptime as variance value. Gives a hint about how much the time is changing.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.TimestampOfLastSocketReceive">
            <summary>
            Stores timestamp of the last time anything (!) was received from the server (including
            low level Ping and ACKs but also events and operation-returns). This is not the time when
            something was dispatched.
            If you enable NetworkSimulation, this value is affected as well.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.ServerAddress">
            <summary>
            The server address which was used in PhotonPeer.Connect() or null (before Connect() was called).
            </summary>
            <remarks>
            The ServerAddress can only be changed for HTTP connections (to replace one that goes through a Loadbalancer with a direct URL).
            </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.UsedProtocol">
            <summary>The protocol this Peer uses to connect to Photon.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.IsSimulationEnabled">
            <summary>
            Gets or sets the network simulation "enabled" setting.
            Changing this value also locks this peer's sending and when setting false,
            the internally used queues are executed (so setting to false can take some cycles).
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.NetworkSimulationSettings">
            <summary>
            Gets the settings for built-in Network Simulation for this peer instance
            while IsSimulationEnabled will enable or disable them.
            Once obtained, the settings can be modified by changing the properties.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.OutgoingStreamBufferSize">
            <summary>
            Defines the initial size of an internally used MemoryStream for Tcp.
            The MemoryStream is used to aggregate operation into (less) send calls,
            which uses less resoures.
            </summary>
            <remarks>
            The size is not restricing the buffer and does not affect when poutgoing data is actually sent.
            </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.MaximumTransferUnit">
            <summary>
            The Maximum Trasfer Unit (MTU) defines the (network-level) packet-content size that is
            guaranteed to arrive at the server in one piece. The Photon Protocol uses this
            size to split larger data into packets and for receive-buffers of packets.
            </summary>
            <remarks>
            This value affects the Packet-content. The resulting UDP packages will have additional
            headers that also count against the package size (so it's bigger than this limit in the end)
            Setting this value while being connected is not allowed and will throw an Exception.
            Minimum is 520. Huge values won't speed up connections in most cases!
            </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.IsEncryptionAvailable">
            <summary>
            This property is set internally, when OpExchangeKeysForEncryption successfully finished.
            While it's true, encryption can be used for operations.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.PhotonPeer.IsSendingOnlyAcks">
            <summary>
            While true, the peer will not send any other commands except ACKs (used in UDP connections).
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.#ctor(ExitGames.Client.Photon.IPhotonPeerListener)">
            <summary>
            Creates a LitePeer instance to connect and communicate with a Photon server.<para></para>
            Uses UDP as protocol (except in the Silverlight library).
            </summary>
            <param name="listener">Your IPhotonPeerListener implementation.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.#ctor">
            <summary>
            Creates a LitePeer instance to connect and communicate with a Photon server.<para></para>
            Uses UDP as protocol (except in the Silverlight library).
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.#ctor(ExitGames.Client.Photon.ConnectionProtocol)">
            <summary>
            Creates a LitePeer instance to connect and communicate with a Photon server.
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.#ctor(ExitGames.Client.Photon.IPhotonPeerListener,ExitGames.Client.Photon.ConnectionProtocol)">
            <summary>
            Creates a LitePeer instance to communicate with Photon with your selection of protocol.
            We recommend UDP.
            </summary>
            <param name="listener">Your IPhotonPeerListener implementation.</param>
            <param name="protocolType">Protocol to use to connect to Photon.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpChangeGroups(System.Byte[],System.Byte[])">
            <summary>
            Operation to handle this client's interest groups (for events in room).
            </summary>
            <remarks>
            Note the difference between passing null and byte[0]:
              null won't add/remove any groups.
              byte[0] will add/remove all (existing) groups.
            First, removing groups is executed. This way, you could leave all groups and join only the ones provided.
            </remarks>
            <param name="groupsToRemove">Groups to remove from interest. Null will not leave any. A byte[0] will remove all.</param>
            <param name="groupsToAdd">Groups to add to interest. Null will not add any. A byte[0] will add all current.</param>
            <returns></returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpRaiseEvent(System.Byte,System.Boolean,System.Object)">
            <summary>
            Send an event with custom code/type and any content to the other players in the same room.
            </summary>
            <remarks>This override explicitly uses another parameter order to not mix it up with the implementation for Hashtable only.</remarks>
            <param name="eventCode">Identifies this type of event (and the content). Your game's event codes can start with 0.</param>
            <param name="sendReliable">If this event has to arrive reliably (potentially repeated if it's lost).</param>
            <param name="customEventContent">Any serializable datatype (including Hashtable like the other OpRaiseEvent overloads).</param>
            <returns>If operation could be enqueued for sending. Sent when calling: Service or SendOutgoingCommands.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpRaiseEvent(System.Byte,System.Boolean,System.Object,System.Byte,ExitGames.Client.Photon.Lite.EventCaching,System.Int32[],ExitGames.Client.Photon.Lite.ReceiverGroup,System.Byte)">
            <summary>
            Send an event with custom code/type and any content to the other players in the same room.
            </summary>
            <remarks>This override explicitly uses another parameter order to not mix it up with the implementation for Hashtable only.</remarks>
            <param name="eventCode">Identifies this type of event (and the content). Your game's event codes can start with 0.</param>
            <param name="sendReliable">If this event has to arrive reliably (potentially repeated if it's lost).</param>
            <param name="customEventContent">Any serializable datatype (including Hashtable like the other OpRaiseEvent overloads).</param>
            <param name="channelId">Command sequence in which this command belongs. Must be less than value of ChannelCount property. Default: 0.</param>
            <param name="cache">Affects how the server will treat the event caching-wise. Can cache events for players joining later on or remove previously cached events. Default: DoNotCache.</param>
            <param name="targetActors">List of ActorNumbers (in this room) to send the event to. Overrides caching. Default: null.</param>
            <param name="receivers">Defines a target-player group. Default: Others.</param>
            <param name="interestGroup">Defines to which interest group the event is sent. Players can subscribe or unsibscribe to groups. Group 0 is always sent to all. Default: 0.</param>
            <returns>If operation could be enqueued for sending. Sent when calling: Service or SendOutgoingCommands.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpRaiseEvent(System.Byte,System.Byte,ExitGames.Client.Photon.Hashtable,System.Boolean)">
            <summary>
            Send your custom data as event to an "interest group" in the current Room.
            </summary>
            <remarks>
            No matter if reliable or not, when an event is sent to a interest Group, some users won't get this data.
            Clients can control the groups they are interested in by using OpChangeGroups.
            </remarks>
            <param name="eventCode">Identifies this type of event (and the content). Your game's event codes can start with 0.</param>
            <param name="interestGroup">The ID of the interest group this event goes to (exclusively). Grouo 0 sends to all.</param>
            <param name="customEventContent">Custom data you want to send along (use null, if none).</param>
            <param name="sendReliable">If this event has to arrive reliably (potentially repeated if it's lost).</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpRaiseEvent(System.Byte,ExitGames.Client.Photon.Hashtable,System.Boolean)">
            <summary>
            RaiseEvent tells the server to send an event to the other players within the same room.
            </summary>
            <remarks>
            This method is described in one of its overloads.
            </remarks>
            <param name="eventCode">Identifies this type of event (and the content). Your game's event codes can start with 0.</param>
            <param name="customEventContent">Custom data you want to send along (use null, if none).</param>
            <param name="sendReliable">If this event has to arrive reliably (potentially repeated if it's lost).</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpRaiseEvent(System.Byte,ExitGames.Client.Photon.Hashtable,System.Boolean,System.Byte)">
             <summary>
             RaiseEvent tells the server to send an event to the other players within the same room.
             </summary>
             <remarks>
             Type and content of the event can be defined by the client side at will. The server only
             forwards the content and eventCode to others in the same room.
            
             The eventCode should be used to define the event's type and content respectively.///
             Lite and Loadbalancing are using a few eventCode values already but those start with 255 and go down.
             Your eventCodes can start at 1, going up.
            
             The customEventContent is a Hashtable with any number of key-value pairs of
             <see cref="!:Serializable Datatypes" text="serializable datatypes"/> or null.
             Receiving clients can access this Hashtable as Parameter LiteEventKey.Data (see below).
            
             RaiseEvent can be used reliable or unreliable. Both result in ordered events but the unreliable ones
             might be lost and allow gaps in the resulting event sequence. On the other hand, they cause less
             overhead and are optimal for data that is replaced soon.
            
             Like all operations, RaiseEvent is not done immediately but when you call SendOutgoingCommands.
            
             It is recommended to keep keys (and data) as simple as possible (e.g. byte or short as key), as
             the data is typically sent multiple times per second. This easily adds up to a huge amount of data
             otherwise.
             </remarks>
             <example>
             <code>
             //send some position data (using byte-keys, as they are small):
            
             Hashtable evInfo = new Hashtable();
             Player local = (Player)players[playerLocalID];
             evInfo.Add((byte)STATUS_PLAYER_POS_X, (int)local.posX);
             evInfo.Add((byte)STATUS_PLAYER_POS_Y, (int)local.posY);
            
             peer.OpRaiseEvent(EV_MOVE, evInfo, true);  //EV_MOVE = (byte)1
            
             //receive this custom event in OnEvent():
             Hashtable data = (Hashtable)photonEvent[LiteEventKey.Data];
             switch (eventCode) {
               case EV_MOVE:               //1 in this sample
                   p = (Player)players[actorNr];
                   if (p != null) {
                       p.posX = (int)data[(byte)STATUS_PLAYER_POS_X];
                       p.posY = (int)data[(byte)STATUS_PLAYER_POS_Y];
                   }
                   break;
             </code>
            
             Events from the Photon Server are internally buffered until they are
             <see cref="M:ExitGames.Client.Photon.PhotonPeer.DispatchIncomingCommands" text="Dispatched"/>, just
             like OperationResults.
             </example>
             <param name="eventCode">Identifies this type of event (and the content). Your game's event codes can start with 0.</param>
             <param name="customEventContent">Custom data you want to send along (use null, if none).</param>
             <param name="sendReliable">If this event has to arrive reliably (potentially repeated if it's lost).</param>
             <param name="channelId">Number of channel (sequence) to use (starting with 0).</param>
             <returns>If operation could be enqueued for sending.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpRaiseEvent(System.Byte,ExitGames.Client.Photon.Hashtable,System.Boolean,System.Byte,System.Int32[])">
             <summary>
             RaiseEvent tells the server to send an event to the other players within the same room.
             </summary>
             <remarks>
             This method is described in one of its overloads.
            
             This variant has an optional list of targetActors. Use this to send the event only to
             specific actors in the same room, each identified by an actorNumber (or ID).
            
             This can be useful to implement private messages inside a room or similar.
             </remarks>
             <param name="eventCode">Identifies this type of event (and the content). Your game's event codes can start with 0.</param>
             <param name="customEventContent">Custom data you want to send along (use null, if none).</param>
             <param name="sendReliable">If this event has to arrive reliably (potentially repeated if it's lost).</param>
             <param name="channelId">Number of channel to use (starting with 0).</param>
             <param name="targetActors">List of actorNumbers that receive this event.</param>
             <returns>If operation could be enqueued for sending.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpRaiseEvent(System.Byte,ExitGames.Client.Photon.Hashtable,System.Boolean,System.Byte,ExitGames.Client.Photon.Lite.EventCaching,ExitGames.Client.Photon.Lite.ReceiverGroup)">
             <summary>
             Calls operation RaiseEvent on the server, with full control of event-caching and the target receivers.
             </summary>
             <remarks>
             This method is described in one of its overloads.
            
             The cache parameter defines if and how this event will be cached server-side. Per event-code, your client
             can store events and update them and will send cached events to players joining the same room.
            
             The option EventCaching.DoNotCache matches the default behaviour of RaiseEvent.
             The option EventCaching.MergeCache will merge the costomEventContent into existing one.
             Values in the customEventContent Hashtable can be null to remove existing values.
            
             With the receivers parameter, you can chose who gets this event: Others (default), All (includes you as sender)
             or MasterClient. The MasterClient is the connected player with the lowest ActorNumber in this room.
             This player could get some privileges, if needed.
            
             Read more about Cached Events in the DevNet: http://doc.exitgames.com
             </remarks>
             <param name="eventCode">Identifies this type of event (and the content). Your game's event codes can start with 0.</param>
             <param name="customEventContent">Custom data you want to send along (use null, if none).</param>
             <param name="sendReliable">If this event has to arrive reliably (potentially repeated if it's lost).</param>
             <param name="channelId">Number of channel to use (starting with 0).</param>
             <param name="cache">Events can be cached (merged and removed) for players joining later on.</param>
             <param name="receivers">Controls who should get this event.</param>
             <returns>If operation could be enqueued for sending.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpSetPropertiesOfActor(System.Int32,ExitGames.Client.Photon.Hashtable,System.Boolean,System.Byte)">
            <summary>
            Attaches or updates properties of the specified actor.
            </summary>
            <remarks>
            Please read the general description of <see cref="!:Properties on Photon"/>.
            </remarks>
            <param name="properties">Hashtable containing the properties to add or update.</param>
            <param name="actorNr">the actorNr is used to identify a player/peer in a game</param>
            <param name="broadcast">true will trigger an event LiteEventKey.PropertiesChanged with the updated properties in it</param>
            <param name="channelId">Number of channel to use (starting with 0).</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpSetPropertiesOfGame(ExitGames.Client.Photon.Hashtable,System.Boolean,System.Byte)">
            <summary>
            Attaches or updates properties of the current game.
            </summary>
            <remarks>
            Please read the general description of <see cref="!:Properties on Photon"/>.
            </remarks>
            <param name="properties">hashtable containing the properties to add or overwrite</param>
            <param name="broadcast">true will trigger an event LiteEventKey.PropertiesChanged with the updated
                                    properties in it</param>
            <param name="channelId">Number of channel to use (starting with 0).</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpGetProperties(System.Byte)">
            <summary>
            Gets all properties of the game and each actor.
            </summary>
            <remarks>
            The server returns only actor properties of players who are in the room when the
            operation executes (players might join or leave while the operation is on it's way).
            Please read the general description of <see cref="!:Properties on Photon"/>.
            </remarks>
            <param name="channelId">Number of channel to use (starting with 0).</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpGetPropertiesOfActor(System.Int32[],System.String[],System.Byte)">
            <summary>
            Gets selected properties of an actor.
            </summary>
            <remarks>
            The server returns only actor properties of players who are in the room when the
            operation executes (players might join or leave while the operation is on it's way).
            Please read the general description of <see cref="!:Properties on Photon"/>.
            </remarks>
            <param name="properties">optional, array of property keys to fetch</param>
            <param name="actorNrList">optional, a list of actornumbers to get the properties of</param>
            <param name="channelId">Number of channel to use (starting with 0).</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpGetPropertiesOfActor(System.Int32[],System.Byte[],System.Byte)">
            <summary>
            Gets selected properties of some actors.
            </summary>
            <remarks>
            The server returns only actor properties of players who are in the room when the
            operation executes (players might join or leave while the operation is on it's way).
            Please read the general description of <see cref="!:Properties on Photon"/>.
            </remarks>
            <param name="properties">array of property keys to fetch. optional (can be null).</param>
            <param name="actorNrList">optional, a list of actornumbers to get the properties of</param>
            <param name="channelId">Number of channel to use (starting with 0).</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpGetPropertiesOfGame(System.String[],System.Byte)">
            <summary>
            Gets selected properties of current game.
            </summary>
            <remarks>
            Please read the general description of <see cref="!:Properties on Photon"/>.
            </remarks>
            <param name="properties">array of property keys to fetch. optional (can be null).</param>
            <param name="channelId">Number of channel to use (starting with 0).</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpGetPropertiesOfGame(System.Byte[],System.Byte)">
            <summary>
            Gets selected properties of current game.
            </summary>
            <remarks>
            Please read the general description of <see cref="!:Properties on Photon"/>.
            </remarks>
            <param name="properties">array of property keys to fetch. optional (can be null).</param>
            <param name="channelId">Number of channel to use (starting with 0).</param>
            <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpJoin(System.String)">
             <summary>
             This operation will join an existing room by name or create one if the name is not in use yet.
            
             Rooms (or games) are simply identified by name. We assume that users always want to get into a room - no matter
             if it existed before or not, so it might be a new one. If you want to make sure a room is created (new, empty),
             the client side might come up with a unique name for it (make sure the name was not taken yet).
            
             The application "Lite Lobby" lists room names and effectively allows the user to select a distinct one.
            
             Each actor (a.k.a. player) in a room will get events that are raised for the room by any player.
            
             To distinguish the actors, each gets a consecutive actornumber. This is used in events to mark who triggered
             the event. A client finds out it's own actornumber in the return callback for operation Join. Number 1 is the
             lowest actornumber in each room and the client with that actornumber created the room.
            
             Each client could easily send custom data around. If the data should be available to newcomers, it makes sense
             to use Properties.
            
             Joining a room will trigger the event <see cref="F:ExitGames.Client.Photon.Lite.LiteEventCode.Join" text="LiteEventCode.Join"/>, which contains
             the list of actorNumbers of current players inside the  room
             (<see cref="F:ExitGames.Client.Photon.Lite.LiteEventKey.ActorList" text="LiteEventKey.ActorList"/>). This also gives you a count of current
             players.
             </summary>
             <param name="gameName">Any identifying name for a room / game.</param>
             <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpJoin(System.String,ExitGames.Client.Photon.Hashtable,ExitGames.Client.Photon.Hashtable,System.Boolean)">
             <summary>
             This operation will join an existing room by name or create one if the name is not in use yet.
            
             Rooms (or games) are simply identified by name. We assume that users always want to get into a room - no matter
             if it existed before or not, so it might be a new one. If you want to make sure a room is created (new, empty),
             the client side might come up with a unique name for it (make sure the name was not taken yet).
            
             The application "Lite Lobby" lists room names and effectively allows the user to select a distinct one.
            
             Each actor (a.k.a. player) in a room will get events that are raised for the room by any player.
            
             To distinguish the actors, each gets a consecutive actornumber. This is used in events to mark who triggered
             the event. A client finds out it's own actornumber in the return callback for operation Join. Number 1 is the
             lowest actornumber in each room and the client with that actornumber created the room.
            
             Each client could easily send custom data around. If the data should be available to newcomers, it makes sense
             to use Properties.
            
             Joining a room will trigger the event <see cref="F:ExitGames.Client.Photon.Lite.LiteEventCode.Join" text="LiteEventCode.Join"/>, which contains
             the list of actorNumbers of current players inside the  room
             (<see cref="F:ExitGames.Client.Photon.Lite.LiteEventKey.ActorList" text="LiteEventKey.ActorList"/>). This also gives you a count of current
             players.
             </summary>
            
             <param name="gameName">Any identifying name for a room / game.</param>
             <param name="gameProperties">optional, set of game properties, by convention: only used if game is new/created</param>
             <param name="actorProperties">optional, set of actor properties</param>
             <param name="broadcastActorProperties">optional, broadcast actor proprties in join-event</param>
             <returns>If operation could be enqueued for sending</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Lite.LitePeer.OpLeave">
            <summary>
            Leave operation of the Lite Application (also in Lite Lobby).
            Leaves a room / game, but keeps the connection. This operations triggers the event <see cref="F:ExitGames.Client.Photon.Lite.LiteEventCode.Leave" text="LiteEventCode.Leave"/>
            for the remaining clients. The event includes the actorNumber of the player who left in key <see cref="F:ExitGames.Client.Photon.Lite.LiteEventKey.ActorNr" text="LiteEventKey.ActorNr"/>.
            </summary>
            <returns>
            Consecutive invocationID of the OP. Will throw Exception if not connected.
            </returns>
        </member>
        <member name="T:ExitGames.Client.Photon.NCommand">
            <summary> Internal class for "commands" - the package in which operations are sent.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.NCommand.#ctor(ExitGames.Client.Photon.EnetPeer,System.Byte,System.Byte[],System.Byte)">
            <summary>this variant does only create outgoing commands and increments . incoming ones are created from a DataInputStream</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.NCommand.#ctor(ExitGames.Client.Photon.EnetPeer,System.Byte[],System.Int32@)">
            <summary>reads the command values (commandHeader and command-values) from incoming bytestream and populates the incoming command*</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.SimulationItem">
            <summary>
            A simulation item is an action that can be queued to simulate network lag.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.SimulationItem.stopw">
            <summary>With this, the actual delay can be measured, compared to the intended lag.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.SimulationItem.TimeToExecute">
            <summary>Timestamp after which this item must be executed.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.SimulationItem.ActionToExecute">
            <summary>Action to execute when the lag-time passed.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.SimulationItem.#ctor">
            <summary>Starts a new Stopwatch</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.NetworkSimulationSet">
            <summary>
            A set of network simulation settings, enabled (and disabled) by PhotonPeer.IsSimulationEnabled.
            </summary>
            <remarks>
            For performance reasons, the lag and jitter settings can't be produced exactly.
            In some cases, the resulting lag will be up to 20ms bigger than the lag settings.
            Even if all settings are 0, simulation will be used. Set PhotonPeer.IsSimulationEnabled 
            to false to disable it if no longer needed.
            
            All lag, jitter and loss is additional to the current, real network conditions.
            If the network is slow in reality, this will add even more lag.
            The jitter values will affect the lag positive and negative, so the lag settings 
            describe the medium lag even with jitter. The jitter influence is: [-jitter..+jitter].
            Packets "lost" due to OutgoingLossPercentage count for BytesOut and LostPackagesOut.
            Packets "lost" due to IncomingLossPercentage count for BytesIn and LostPackagesIn.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.NetworkSimulationSet.isSimulationEnabled">
            <summary>internal</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.NetworkSimulationSet.outgoingLag">
            <summary>internal</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.NetworkSimulationSet.outgoingJitter">
            <summary>internal</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.NetworkSimulationSet.outgoingLossPercentage">
            <summary>internal</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.NetworkSimulationSet.incomingLag">
            <summary>internal</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.NetworkSimulationSet.incomingJitter">
            <summary>internal</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.NetworkSimulationSet.incomingLossPercentage">
            <summary>internal</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.IsSimulationEnabled">
            <summary>This setting overrides all other settings and turns simulation on/off. Default: false.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.OutgoingLag">
            <summary>Outgoing packages delay in ms. Default: 100.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.OutgoingJitter">
            <summary>Randomizes OutgoingLag by [-OutgoingJitter..+OutgoingJitter]. Default: 0.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.OutgoingLossPercentage">
            <summary>Percentage of outgoing packets that should be lost. Between 0..100. Default: 1. TCP ignores this setting.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.IncomingLag">
            <summary>Incoming packages delay in ms. Default: 100.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.IncomingJitter">
            <summary>Randomizes IncomingLag by [-IncomingJitter..+IncomingJitter]. Default: 0.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.IncomingLossPercentage">
            <summary>Percentage of incoming packets that should be lost. Between 0..100. Default: 1. TCP ignores this setting.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.LostPackagesOut">
            <summary>Counts how many outgoing packages actually got lost. TCP connections ignore loss and this stays 0.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.NetworkSimulationSet.LostPackagesIn">
            <summary>Counts how many incoming packages actually got lost. TCP connections ignore loss and this stays 0.</summary>
        </member>
        <member name="T:Photon.SocketServer.Security.OakleyGroups">
            <summary>
            Provides classical Diffie-Hellman Modular Exponentiation Groups defined by the 
            OAKLEY Key Determination Protocol (RFC 2412).
            </summary>
        </member>
        <member name="F:Photon.SocketServer.Security.OakleyGroups.Generator">
            <summary>
            Gets the genrator (N) used by the the well known groups 1,2 and 5.
            </summary>
        </member>
        <member name="F:Photon.SocketServer.Security.OakleyGroups.OakleyPrime768">
            <summary>
            Gets the 768 bit prime for the well known group 1. 
            </summary>
        </member>
        <member name="F:Photon.SocketServer.Security.OakleyGroups.OakleyPrime1024">
            <summary>
            Gets the 1024 bit prime for the well known group 2. 
            </summary>
        </member>
        <member name="F:Photon.SocketServer.Security.OakleyGroups.OakleyPrime1536">
            <summary>
            Gets the 1536  bit prime for the well known group 5. 
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PhotonCodes.Ok">
            <summary>Result code for any (internal) operation.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PhotonCodes.ClientKey">
            <summary>Param code. Used in internal op: InitEncryption.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PhotonCodes.ModeKey">
            <summary>Encryption-Mode code. Used in internal op: InitEncryption.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PhotonCodes.ServerKey">
            <summary>Param code. Used in internal op: InitEncryption.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PhotonCodes.InitEncryption">
            <summary>Code of internal op: InitEncryption.</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.PeerStateValue">
            <summary>
            Value range for a Peer's connection and initialization state, as returned by the PeerState property.
            </summary>
            <remarks>
            While this is not the same as the StatusCode of IPhotonPeerListener.OnStatusChanged(), it directly relates to it.
            In most cases, it makes more sense to build a game's state on top of the OnStatusChanged() as you get changes.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerStateValue.Disconnected">
            <summary>The peer is disconnected and can't call Operations. Call Connect().</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerStateValue.Connecting">
            <summary>The peer is establishing the connection: opening a socket, exchanging packages with Photon.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerStateValue.InitializingApplication">
            <summary>The connection is established and now sends the application name to Photon.</summary>
            <remarks>You set the "application name" by calling PhotonPeer.Connect().</remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerStateValue.Connected">
            <summary>The peer is connected and initialized (selected an application). You can now use operations.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.PeerStateValue.Disconnecting">
            <summary>The peer is disconnecting. It sent a disconnect to the server, which will acknowledge closing the connection.</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.ConnectionProtocol">
            <summary>
            These are the options that can be used as underlying transport protocol.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.ConnectionProtocol.Udp">
            <summary>Use UDP to connect to Photon, which allows you to send operations reliable or unreliable on demand.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.ConnectionProtocol.Tcp">
            <summary>Use TCP to connect to Photon.</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.DebugLevel">
            <summary>
            Level / amount of DebugReturn callbacks. Each debug level includes output for lower ones: OFF, ERROR, WARNING, INFO, ALL.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.DebugLevel.OFF">
            <summary>No debug out.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.DebugLevel.ERROR">
            <summary>Only error descriptions.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.DebugLevel.WARNING">
            <summary>Warnings and errors.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.DebugLevel.INFO">
            <summary>Information about internal workflows, warnings and errors.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.DebugLevel.ALL">
            <summary>Most complete workflow description (but lots of debug output), info, warnings and errors.</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.PingMono">
            <summary>Uses C# Socket class from System.Net.Sockets (as Unity usually does).</summary>
            <remarks>Incompatible with Windows 8 Store/Phone API.</remarks>
        </member>
        <member name="T:ExitGames.Client.Photon.OperationRequest">
            <summary>
            Container for an Operation request, which is a code and parameters.
            </summary>
            <remarks>
            On the lowest level, Photon only allows byte-typed keys for operation parameters.
            The values of each such parameter can be any serializable datatype: byte, int, hashtable and many more.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.OperationRequest.OperationCode">
            <summary>Byte-typed code for an operation - the short identifier for the server's method to call.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.OperationRequest.Parameters">
            <summary>The parameters of the operation - each identified by a byte-typed code in Photon.</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.OperationResponse">
            <summary>
            Contains the server's response for an operation called by this peer.
            The indexer of this class actually provides access to the Parameters Dictionary.
            </summary>
            <remarks>
            The OperationCode defines the type of operation called on Photon and in turn also the Parameters that
            are set in the request. Those are provided as Dictionary with byte-keys.
            There are pre-defined constants for various codes defined in the Lite application. Check: LiteOpCode,
            LiteOpKey, etc.
            <para></para>
            An operation's request is summarized by the ReturnCode: a short typed code for &quot;Ok&quot; or
            some different result. The code's meaning is specific per operation. An optional DebugMessage can be
            provided to simplify debugging.
            <para></para>
            Each call of an operation gets an ID, called the &quot;invocID&quot;. This can be matched to the IDs
            returned with any operation calls. This way, an application could track if a certain OpRaiseEvent
            call was successful.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.OperationResponse.OperationCode">
            <summary>The code for the operation called initially (by this peer).</summary>
            <remarks>Use enums or constants to be able to handle those codes, like LiteOpCode does.</remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.OperationResponse.ReturnCode">
            <summary>A code that &quot;summarizes&quot; the operation's success or failure. Specific per operation. 0 usually means "ok".</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.OperationResponse.DebugMessage">
            <summary>An optional string sent by the server to provide readable feedback in error-cases. Might be null.</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.OperationResponse.Parameters">
            <summary>A Dictionary of values returned by an operation, using byte-typed keys per value.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.OperationResponse.ToString">
            <summary>ToString() override.</summary>
            <returns>Relatively short output of OpCode and returnCode.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.OperationResponse.ToStringFull">
            <summary>Extensive output of operation results.</summary>
            <returns>To be used in debug situations only, as it returns a string for each value.</returns>
        </member>
        <member name="P:ExitGames.Client.Photon.OperationResponse.Item(System.Byte)">
            <summary>
            Alternative access to the Parameters, which wraps up a TryGetValue() call on the Parameters Dictionary.
            </summary>
            <param name="parameterCode">The byte-code of a returned value.</param>
            <returns>The value returned by the server, or null if the key does not exist in Parameters.</returns>
        </member>
        <member name="T:ExitGames.Client.Photon.EventData">
            <summary>
            Contains all components of a Photon Event.
            Event Parameters, like OperationRequests and OperationResults, consist of a Dictionary with byte-typed keys per value.
            </summary>
            <remarks>
            The indexer of this class actually provides access to the Parameters Dictionary.
            The operation RaiseEvent of the Lite application allows you to provide custom event content. Defined in Lite, this
            CustomContent will be made the value of key LiteEventKey.OperationRaiseEvent which is (byte)42.
            Enums and constants for the Lite-Application codes are defined in the LitePeer namespace. Check: LiteEventKey, etc.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.EventData.Code">
            <summary>The event code identifies the type of event.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:ExitGames.Client.Photon.EventData.Parameters" -->
        <member name="M:ExitGames.Client.Photon.EventData.ToString">
            <summary>ToString() override.</summary>
            <returns>Short output of "Event" and it's Code.</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.EventData.ToStringFull">
            <summary>Extensive output of the event content.</summary>
            <returns>To be used in debug situations only, as it returns a string for each value.</returns>
        </member>
        <member name="P:ExitGames.Client.Photon.EventData.Item(System.Byte)">
            <summary>
            Alternative access to the Parameters.
            </summary>
            <param name="key">The key byte-code of a event value.</param>
            <returns>The Parameters value, or null if the key does not exist in Parameters.</returns>
        </member>
        <member name="T:ExitGames.Client.Photon.GpType">
            <summary>
              The gp type.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.Unknown">
            <summary>
              Unkown type.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.Array">
            <summary>
              An array of objects.
            </summary>
            <remarks>
              This type is new in version 1.5.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.Boolean">
            <summary>
              A boolean Value.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.Byte">
            <summary>
              A byte value.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.ByteArray">
            <summary>
              An array of bytes.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.ObjectArray">
            <summary>
              An array of objects.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.Short">
            <summary>
              A 16-bit integer value.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.Float">
            <summary>
              A 32-bit floating-point value.
            </summary>
            <remarks>
              This type is new in version 1.5.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.Dictionary">
            <summary>
              A dictionary
            </summary>
            <remarks>
              This type is new in version 1.6.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.Double">
            <summary>
              A 64-bit floating-point value.
            </summary>
            <remarks>
              This type is new in version 1.5.
            </remarks>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.Hashtable">
            <summary>
              A Hashtable.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.Integer">
            <summary>
              A 32-bit integer value.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.IntegerArray">
            <summary>
              An array of 32-bit integer values.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.Long">
            <summary>
              A 64-bit integer value.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.String">
            <summary>
              A string value.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.StringArray">
            <summary>
              An array of string values.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.Custom">
            <summary>
              A costum type
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.GpType.Null">
            <summary>
              Null value don't have types.
            </summary>
        </member>
        <member name="T:ExitGames.Client.Photon.SerializeMethod">
            <summary>
            Type of serialization methods to add custom type support.
            Use PhotonPeer.ReisterType() to register new types with serialization and deserialization methods.
            </summary>
            <param name="customObject">The method will get objects passed that were registered with it in RegisterType().</param>
            <returns>Return a byte[] that resembles the object passed in. The framework will surround it with length and type info, so don't include it.</returns>
        </member>
        <member name="T:ExitGames.Client.Photon.DeserializeMethod">
            <summary>
            Type of deserialization methods to add custom type support.
            Use PhotonPeer.RegisterType() to register new types with serialization and deserialization methods.
            </summary>
            <param name="serializedCustomObject">The framwork passes in the data it got by the associated SerializeMethod. The type code and length are stripped and applied before a DeserializeMethod is called.</param>
            <returns>Return a object of the type that was associated with this method through RegisterType().</returns>
        </member>
        <member name="T:ExitGames.Client.Photon.Protocol">
            <summary>
            Provides tools for the Exit Games Protocol
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.Protocol.Serialize(System.Object)">
            <summary>
            Serialize creates a byte-array from the given object and returns it.
            </summary>
            <param name="obj">The object to serialize</param>
            <returns>The serialized byte-array</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Protocol.Deserialize(System.Byte[])">
            <summary>
            Deserialize returns an object reassembled from the given byte-array.
            </summary>
            <param name="serializedData">The byte-array to be Deserialized</param>
            <returns>The Deserialized object</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.Protocol.Serialize(System.IO.MemoryStream,System.Object,System.Boolean)">
            <summary>
            Calls the correct serialization method for the passed object.
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.Protocol.Serialize(System.Int16,System.Byte[],System.Int32@)">
            <summary>
            Serializes a short typed value into a byte-array (target) starting at the also given targetOffset.
            The altered offset is known to the caller, because it is given via a referenced parameter.
            </summary>
            <param name="value">The short value to be serialized</param>
            <param name="target">The byte-array to serialize the short to</param>
            <param name="targetOffset">The offset in the byte-array</param>
        </member>
        <member name="M:ExitGames.Client.Photon.Protocol.Serialize(System.Int32,System.Byte[],System.Int32@)">
            <summary>
            Serializes an int typed value into a byte-array (target) starting at the also given targetOffset.
            The altered offset is known to the caller, because it is given via a referenced parameter.
            </summary>
            <param name="value">The int value to be serialized</param>
            <param name="target">The byte-array to serialize the short to</param>
            <param name="targetOffset">The offset in the byte-array</param>
        </member>
        <member name="M:ExitGames.Client.Photon.Protocol.Serialize(System.Single,System.Byte[],System.Int32@)">
            <summary>
            Serializes an float typed value into a byte-array (target) starting at the also given targetOffset.
            The altered offset is known to the caller, because it is given via a referenced parameter.
            </summary>
            <param name="value">The float value to be serialized</param>
            <param name="target">The byte-array to serialize the short to</param>
            <param name="targetOffset">The offset in the byte-array</param>
        </member>
        <member name="M:ExitGames.Client.Photon.Protocol.Deserialize(System.Int16@,System.Byte[],System.Int32@)">
            <summary>
            Deserialize fills the given short typed value with the given byte-array (source) starting at the also given offset.
            The result is placed in a variable (value). There is no need to return a value because the parameter value is given by reference.
            The altered offset is this way also known to the caller.
            </summary>
            <param name="value">The short value to deserialized into</param>
            <param name="source">The byte-array to deserialize from</param>
            <param name="offset">The offset in the byte-array</param>
        </member>
        <member name="M:ExitGames.Client.Photon.Protocol.DeserializeInteger(System.IO.MemoryStream)">
            <summary>
            DeserializeInteger returns an Integer typed value from the given Memorystream.
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.Protocol.Deserialize(System.Int32@,System.Byte[],System.Int32@)">
            <summary>
            Deserialize fills the given int typed value with the given byte-array (source) starting at the also given offset.
            The result is placed in a variable (value). There is no need to return a value because the parameter value is given by reference.
            The altered offset is this way also known to the caller.
            </summary>
            <param name="value">The int value to deserialize into</param>
            <param name="source">The byte-array to deserialize from</param>
            <param name="offset">The offset in the byte-array</param>
        </member>
        <member name="M:ExitGames.Client.Photon.Protocol.Deserialize(System.Single@,System.Byte[],System.Int32@)">
            <summary>
            Deserialize fills the given float typed value with the given byte-array (source) starting at the also given offset.
            The result is placed in a variable (value). There is no need to return a value because the parameter value is given by reference.
            The altered offset is this way also known to the caller.
            </summary>
            <param name="value">The float value to deserialize</param>
            <param name="source">The byte-array to deserialize from</param>
            <param name="offset">The offset in the byte-array</param>
        </member>
        <member name="T:ExitGames.Client.Photon.SocketTcp">
            <summary>
            Internal class to encapsulate the network i/o functionality for the realtime libary.
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.SocketTcp.Send(System.Byte[],System.Int32)">
            <summary>
            used by TPeer*
            </summary>
        </member>
        <member name="T:ExitGames.Client.Photon.SocketUdp">
            <summary> Internal class to encapsulate the network i/o functionality for the realtime libary.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.SocketUdp.Send(System.Byte[],System.Int32)">
            <summary>used by PhotonPeer*</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.SocketUdp.ReceiveLoop">
            <summary>Endless loop, run in Receive Thread.</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.SupportClass">
            <summary>
            Contains several (more or less) useful static methods, mostly used for debugging.
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.GetTickCount">
            <summary>
            Gets the local machine's "milliseconds since start" value (precision is described in remarks).
            </summary>
            <remarks>
            This method uses Environment.TickCount (cheap but with only 16ms precision).
            PhotonPeer.LocalMsTimestampDelegate is available to set the delegate (unless already connected).
            </remarks>
            <returns>Fraction of the current time in Milliseconds (this is not a proper datetime timestamp).</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.CallInBackground(System.Func{System.Boolean})">
            <summary>
            Creates a background thread that calls the passed function in 100ms intervals, as long as that returns true.
            </summary>
            <param name="myThread"></param>
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.CallInBackground(System.Func{System.Boolean},System.Int32)">
            <summary>
            Creates a background thread that calls the passed function in 100ms intervals, as long as that returns true.
            </summary>
            <param name="myThread"></param>
            <param name="millisecondsInterval">Milliseconds to sleep between calls of myThread.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.WriteStackTrace(System.Exception,System.IO.TextWriter)">
            <summary>
            Writes the exception's stack trace to the received stream.
            </summary>
            <param name="throwable">Exception to obtain information from.</param>
            <param name="stream">Output sream used to write to.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.WriteStackTrace(System.Exception)">
            <summary>
            Writes the exception's stack trace to the received stream. Writes to: System.Diagnostics.Debug.
            </summary>
            <param name="throwable">Exception to obtain information from.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.DictionaryToString(System.Collections.IDictionary)">
            <summary>
            This method returns a string, representing the content of the given IDictionary.
            Returns "null" if parameter is null.
            </summary>
            <param name="dictionary">
            IDictionary to return as string.
            </param>
            <returns>
            The string representation of keys and values in IDictionary.
            </returns>
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.DictionaryToString(System.Collections.IDictionary,System.Boolean)">
            <summary>
            This method returns a string, representing the content of the given IDictionary.
            Returns "null" if parameter is null.
            </summary>
            <param name="dictionary">IDictionary to return as string.</param>
            <param name="includeTypes"> </param>
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.NumberToByteArray(System.Byte[],System.Int32,System.Int16)">
            <summary>
            Inserts the number's value into the byte array, using Big-Endian order (a.k.a. Network-byte-order).
            </summary>
            <param name="buffer">Byte array to write into.</param>
            <param name="index">Index of first position to write to.</param>
            <param name="number">Number to write.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.NumberToByteArray(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Inserts the number's value into the byte array, using Big-Endian order (a.k.a. Network-byte-order).
            </summary>
            <param name="buffer">Byte array to write into.</param>
            <param name="index">Index of first position to write to.</param>
            <param name="number">Number to write.</param>
        </member>
        <member name="M:ExitGames.Client.Photon.SupportClass.ByteArrayToString(System.Byte[])">
            <summary>
            Converts a byte-array to string (useful as debugging output).
            Uses BitConverter.ToString(list) internally after a null-check of list.
            </summary>
            <param name="list">Byte-array to convert to string.</param>
            <returns>
            List of bytes as string.
            </returns>
        </member>
        <member name="T:ExitGames.Client.Photon.SupportClass.ThreadSafeRandom">
            <summary>
            Class to wrap static access to the random.Next() call in a thread safe manner.
            </summary>
        </member>
        <member name="F:ExitGames.Client.Photon.TPeer.TCP_HEADER_BYTES">
            <summary>TCP "Package" header: 7 bytes</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.TPeer.MSG_HEADER_BYTES">
            <summary>TCP "Message" header: 2 bytes</summary>
        </member>
        <member name="F:ExitGames.Client.Photon.TPeer.ALL_HEADER_BYTES">
            <summary>TCP header combined: 9 bytes</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.TPeer.DispatchIncomingCommands">
            <summary>
            Checks the incoming queue and Dispatches received data if possible. Returns if a Dispatch happened or
            not, which shows if more Dispatches might be needed.
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.TPeer.SendOutgoingCommands">
            <summary>
            gathers commands from all (out)queues until udp-packet is full and sends it!
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.TPeer.SendAcksOnly">
            <summary>Sends a ping in intervals to keep connection alive (server will timeout connection if nothing is sent).</summary>
            <returns>Always false in this case (local queues are ignored. true would be: "call again to send remaining data").</returns>
        </member>
        <member name="M:ExitGames.Client.Photon.TPeer.SerializeOperationToMessage(System.Byte,System.Collections.Generic.Dictionary{System.Byte,System.Object},ExitGames.Client.Photon.PeerBase.EgMessageType,System.Boolean)">
            <summary> Returns the UDP Payload starting with Magic Number for binary protocol </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.TPeer.EnqueueMessageAsPayload(System.Boolean,System.Byte[],System.Byte)">
            <summary>enqueues serialized operations to be sent as tcp stream / package</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.TPeer.SendPing">
            <summary>Sends a ping and modifies this.lastPingResult to avoid another ping for a while.</summary>
        </member>
        <member name="M:ExitGames.Client.Photon.TPeer.ReceiveIncomingCommands(System.Byte[],System.Int32)">
            <summary>reads incoming tcp-packages to create and queue incoming commands*</summary>
        </member>
        <member name="T:ExitGames.Client.Photon.TrafficStatsGameLevel">
            <summary>
            Only in use as long as PhotonPeer.TrafficStatsEnabled = true;
            </summary>
        </member>
        <member name="M:ExitGames.Client.Photon.TrafficStatsGameLevel.ResetMaximumCounters">
            <summary>
            Resets the values that can be maxed out, like LongestDeltaBetweenDispatching. See remarks.
            </summary>
            <remarks>
            Set to 0: LongestDeltaBetweenDispatching, LongestDeltaBetweenSending, LongestEventCallback, LongestEventCallbackCode, LongestOpResponseCallback, LongestOpResponseCallbackOpCode.
            Also resets internal values: timeOfLastDispatchCall and timeOfLastSendCall (so intervals are tracked correctly).
            </remarks>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.OperationByteCount">
            <summary>Gets sum of outgoing operations in bytes.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.OperationCount">
            <summary>Gets count of outgoing operations.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.ResultByteCount">
            <summary>Gets sum of byte-cost of incoming operation-results.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.ResultCount">
            <summary>Gets count of incoming operation-results.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.EventByteCount">
            <summary>Gets sum of byte-cost of incoming events.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.EventCount">
            <summary>Gets count of incoming events.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.LongestOpResponseCallback">
            <summary>
            Gets longest time it took to complete a call to OnOperationResponse (in your code).
            If such a callback takes long, it will lower the network performance and might lead to timeouts.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.LongestOpResponseCallbackOpCode">
            <summary>Gets OperationCode that causes the LongestOpResponseCallback. See that description.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.LongestEventCallback">
            <summary>
            Gets longest time a call to OnEvent (in your code) took.
            If such a callback takes long, it will lower the network performance and might lead to timeouts.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.LongestEventCallbackCode">
            <summary>Gets EventCode that caused the LongestEventCallback. See that description.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.LongestDeltaBetweenDispatching">
            <summary>
            Gets longest time between subsequent calls to DispatchIncomginCommands in milliseconds.
            Note: This is not a crucial timing for the networking. Long gaps just add "local lag" to events that are available already.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.LongestDeltaBetweenSending">
            <summary>
            Gets longest time between subsequent calls to SendOutgoingCommands in milliseconds.
            Note: This is a crucial value for network stability. Without calling SendOutgoingCommands,
            nothing will be sent to the server, who might time out this client.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.DispatchCalls">
            <summary>
            Gets number of calls of DispatchIncomingCommands.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.DispatchIncomingCommandsCalls">
            <summary>
            Gets number of calls of DispatchIncomingCommands.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.SendOutgoingCommandsCalls">
            <summary>
            Gets number of calls of SendOutgoingCommands.
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.TotalByteCount">
            <summary>Gets sum of byte-cost of all "logic level" messages.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.TotalMessageCount">
            <summary>Gets sum of counted "logic level" messages.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.TotalIncomingByteCount">
            <summary>Gets sum of byte-cost of all incoming "logic level" messages.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.TotalIncomingMessageCount">
            <summary>Gets sum of counted incoming "logic level" messages.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.TotalOutgoingByteCount">
            <summary>Gets sum of byte-cost of all outgoing "logic level" messages (= OperationByteCount).</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStatsGameLevel.TotalOutgoingMessageCount">
            <summary>Gets sum of counted outgoing "logic level" messages (= OperationCount).</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStats.PackageHeaderSize">
            <summary>Gets the byte-size of per-package headers.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStats.ReliableCommandCount">
            <summary>
            Counts commands created/received by this client, ignoring repeats (out command count can be higher due to repeats).
            </summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStats.TotalPacketBytes">
            <summary>Gets count of bytes as traffic, excluding UDP/TCP headers (42 bytes / x bytes).</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStats.TimestampOfLastAck">
            <summary>Timestamp of the last incoming ACK read (every second this client sends a PING which must be ACKd.</summary>
        </member>
        <member name="P:ExitGames.Client.Photon.TrafficStats.TimestampOfLastReliableCommand">
            <summary>Timestamp of last incoming reliable command (every second we expect a PING).</summary>
        </member>
    </members>
</doc>
